/*
 * This file was generated by the generate_ast.py script.
 */

#include <optional>

#include "ast/ast.hpp"


Expression::Binary::Binary(std::unique_ptr<Expression> left, Token op, std::unique_ptr<Expression> right) : left{std::move(left)}, op{std::move(op)}, right{std::move(right)} {}
void Expression::Binary::accept(Expression::Visitor& visitor) const { visitor.visit(*this); }


Expression::Grouping::Grouping(std::unique_ptr<Expression> expression) : expression{std::move(expression)} {}
void Expression::Grouping::accept(Expression::Visitor& visitor) const { visitor.visit(*this); }


Expression::Literal::Literal(Token::Literal value) : value{std::move(value)} {}
void Expression::Literal::accept(Expression::Visitor& visitor) const { visitor.visit(*this); }


Expression::Unary::Unary(Token op, std::unique_ptr<Expression> right) : op{std::move(op)}, right{std::move(right)} {}
void Expression::Unary::accept(Expression::Visitor& visitor) const { visitor.visit(*this); }


Expression::Variable::Variable(Token name) : name{std::move(name)} {}
void Expression::Variable::accept(Expression::Visitor& visitor) const { visitor.visit(*this); }


Expression::Assignment::Assignment(Token name, std::unique_ptr<Expression> value) : name{std::move(name)}, value{std::move(value)} {}
void Expression::Assignment::accept(Expression::Visitor& visitor) const { visitor.visit(*this); }


Statement::Expression::Expression(std::unique_ptr<::Expression> expression) : expression{std::move(expression)} {}
void Statement::Expression::accept(Statement::Visitor& visitor) const { visitor.visit(*this); }


Statement::Print::Print(Token keyword, std::unique_ptr<::Expression> expression) : keyword{std::move(keyword)}, expression{std::move(expression)} {}
void Statement::Print::accept(Statement::Visitor& visitor) const { visitor.visit(*this); }


Statement::VariableDeclaration::VariableDeclaration(Token name, std::unique_ptr<::Expression> initializer) : name{std::move(name)}, initializer{std::move(initializer)} {}
void Statement::VariableDeclaration::accept(Statement::Visitor& visitor) const { visitor.visit(*this); }


Statement::Block::Block(std::vector<std::unique_ptr<Statement>> statements) : statements{std::move(statements)} {}
void Statement::Block::accept(Statement::Visitor& visitor) const { visitor.visit(*this); }


Statement::IfElse::IfElse(std::unique_ptr<::Expression> condition, Token if_keyword, std::unique_ptr<Statement> then_statement, std::optional<Token> else_keyword, std::unique_ptr<Statement> else_statement) : condition{std::move(condition)}, if_keyword{std::move(if_keyword)}, then_statement{std::move(then_statement)}, else_keyword{std::move(else_keyword)}, else_statement{std::move(else_statement)} {}
void Statement::IfElse::accept(Statement::Visitor& visitor) const { visitor.visit(*this); }
