"""AST Generator

Generates the AST classes for the parser. Writes to stdout.
Accepts the output programming language.
"""

import abc
import argparse


class Field:
    def __init__(
        self,
        name: str,
        type: str,
    ):
        self.name = name
        self.type = type


class Type:
    def __init__(
        self,
        name: str,
        fields: list[Field],
        parent: str = None,
    ):
        self.name = name
        self.fields = fields
        self.parent = parent


class ABC:
    def __init__(
        self,
        name: str,
        parent: str = None,
    ):
        self.name = name
        self.parent = parent


TYPES = [
    ABC("Expression"),
    Type("Binary", [Field("left", "Expression"), Field("operator", "Token"), Field("right", "Expression")], "Expression"),
    Type("Grouping", [Field("expression", "Expression")], "Expression"),
    Type("Literal", [Field("value", "std::variant<std::nullptr_t, std::string, double, bool>")], "Expression"),
    Type("Unary", [Field("operator", "Token"), Field("right", "Expression")], "Expression"),
]


class AstMetaProgrammer (abc.ABC):
    def __init__(self, types: list[Type]):
        self._types = types
        self._visitable_types = [
            type.name
            for type in types
            if not isinstance(types, ABC)
        ]

    def generate(self) -> str:
        return "".join([
            self.generate_docstring(),
            self.generate_includes(),
            self.generate_ast_classes(),
            self.generate_visitor(),
            "\n"
        ])

    @abc.abstractmethod
    def generate_docstring(self) -> str:
        pass

    @abc.abstractmethod
    def generate_includes(self) -> str:
        pass

    @abc.abstractmethod
    def generate_ast_classes(self) -> str:
        pass

    @abc.abstractmethod
    def generate_visitor(self) -> str:
        pass


class CppAstMetaProgrammer (AstMetaProgrammer):
    def __init__(self, types: list[Type], cli_args):
        super().__init__(types)
        parser = argparse.ArgumentParser()
        parser.add_argument("--header", required=True)
        args = parser.parse_args(cli_args)
        self._includes = [args.header]


    def generate_docstring(self):
        return "/*\n * This file was generated by the generate_ast.py script.\n */"

    def generate_includes(self):
        if not self._includes:
            return ""
        return "\n\n" + "\n".join([
            f"#include {include}"
            for include in self._includes
        ])


    def generate_ast_classes(self):
        return "".join([
            self.generate_ast_class(t)
            for t in self._types
        ])

    def generate_ast_class(self, t: Type):
        return self.generate_ast_class_methods(t)

    def generate_ast_class_methods(self, t: Type):
        if isinstance(t, ABC):
            return ""
        return f"\n\n\nvoid {t.name}::accept(Visitor& visitor) const override {{ visitor.visit(*this); }}"

    def generate_visitor(self):
        return ""


class HppAstMetaProgrammer (AstMetaProgrammer):
    def __init__(self, types: list[Type], cli_args):
        super().__init__(types)

    def generate_docstring(self):
        return "/*\n * This file was generated by the generate_ast.py script.\n */"

    def generate_includes(self):
        return ""

    def generate_ast_classes(self):
        return "".join(
            [self.generate_visitor_forward_declaration()]
            + [
                self.generate_ast_class(t)
                for t in self._types
            ]
        )

    def generate_visitor_forward_declaration(self):
        return "\n\n\nclass Visitor;"

    def generate_ast_class(self, t: Type):
        return "".join([
            self.generate_ast_class_header(t),
            self.generate_ast_class_methods(t),
            self.generate_ast_class_fields(t),
            self.generate_ast_class_footer(t),
        ])

    def generate_ast_class_header(self, t: Type):
        if isinstance(t, ABC):
            return f"\n\n\nstruct {t.name}\n{{"
        return f"\n\n\nstruct {t.name} : {t.parent}\n{{"

    def generate_ast_class_methods(self, t: Type):
        if isinstance(t, ABC):
            return "\n    virtual void accept(Visitor& visitor) const = 0;"
        return "\n    void accept(Visitor& visitor) const override;"

    def generate_ast_class_fields(self, t: Type):
        if isinstance(t, ABC):
            return ""
        return "\n".join([""] + [f"    const {field.type} {field.name};" for field in t.fields])

    def generate_ast_class_footer(self, t: Type):
        return "\n};"

    def generate_visitor(self):
        return "".join([
            self.generate_visitor_header(),
            self.generate_visitor_methods(),
            self.generate_visitor_footer(),
        ])

    def generate_visitor_header(self):
        return "\n\n\nclass Visitor\n{"

    def generate_visitor_methods(self):
        return "".join([
            f"\n    virtual void visit(const {type}& {type.lower()}) = 0;"
            for type in self._visitable_types
        ])

    def generate_visitor_footer(self):
        return "\n};"


def parse_args():
    parser = argparse.ArgumentParser(
        description="Generate AST classes for the parser.",
    )
    parser.add_argument(
        "language",
        choices=["cpp", "hpp"],
        help="The output programming language.",
    )
    return parser.parse_known_args()


METAPROGRAMMER_BY_LANGUAGE = {
    "cpp": CppAstMetaProgrammer,
    "hpp": HppAstMetaProgrammer,
}


def main():
    known_args, unknown_args = parse_args()
    if known_args.language not in METAPROGRAMMER_BY_LANGUAGE:
        raise ValueError(f"Unknown language: {known_args.language}")
    metaprogrammer = METAPROGRAMMER_BY_LANGUAGE[known_args.language](TYPES, cli_args=unknown_args)
    print(metaprogrammer.generate(), end="")


if __name__ == "__main__":
    main()
