"""AST Metaprogrammer

Generates the AST classes for the parser. Writes to stdout.
Accepts the output programming language and whether to generate
the AST classes as declarations or definitions.
"""

import abc
import argparse


class Field:
    def __init__(
        self,
        name: str,
        type: str,
    ):
        self.name = name
        self.type = type


class Type:
    def __init__(
        self,
        name: str,
        fields: list[Field],
        parent: str = None,
    ):
        self.name = name
        self.fields = fields
        self.parent = parent


class ABC:
    def __init__(
        self,
        name: str,
        parent: str = None,
    ):
        self.name = name
        self.parent = parent


TYPES = [
    ABC("Expression"),
    Type("Binary", [Field("left", "Expression"), Field("operator", "Token"), Field("right", "Expression")], "Expression"),
    Type("Grouping", [Field("expression", "Expression")], "Expression"),
    Type("Literal", [Field("value", "std::variant<std::nullptr_t, std::string, double, bool>")], "Expression"),
    Type("Unary", [Field("operator", "Token"), Field("right", "Expression")], "Expression"),
]


class AstMetaProgrammer (abc.ABC):
    def __init__(self, types: list[Type]):
        self._types = types
        self._visitable_types = [
            type.name
            for type in types
            if not isinstance(types, ABC)
        ]

    def generate(self) -> str:
        return "".join([
            self.generate_docstring(),
            self.generate_includes(),
            self.generate_ast_classes(),
            self.generate_visitor(),
            "\n"
        ])

    @abc.abstractmethod
    def generate_docstring(self) -> str:
        pass

    @abc.abstractmethod
    def generate_includes(self) -> str:
        pass

    @abc.abstractmethod
    def generate_ast_classes(self) -> str:
        pass

    @abc.abstractmethod
    def generate_visitor(self) -> str:
        pass


class CppAstMetaProgrammer (AstMetaProgrammer):
    def __init__(self, types: list[Type], declaration: bool = False):
        super().__init__(types)
        self._declaration = declaration

    def generate_docstring(self):
        return "/*\n * This file is generated by the ast_metaprogrammer.py script.\n */"

    def generate_includes(self):
        return ""

    def generate_ast_classes(self):
        result = []
        if self._declaration:
            result.append(self.generate_visitor_forward_declaration())
        result.extend([
            self.generate_ast_class(t)
            for t in self._types
        ])
        return "".join(result)

    def generate_visitor_forward_declaration(self):
        return "\n\n\nclass Visitor;"

    def generate_ast_class(self, t: Type):
        if self._declaration:
            return "".join([
                self.generate_ast_class_header(t),
                self.generate_ast_class_methods(t),
                self.generate_ast_class_fields(t),
                self.generate_ast_class_footer(t),
            ])
        return self.generate_ast_class_methods(t)

    def generate_ast_class_header(self, t: Type):
        if isinstance(t, ABC):
            return f"\n\n\nstruct {t.name}\n{{"
        return f"\n\n\nstruct {t.name} : {t.parent}\n{{"

    def generate_ast_class_methods(self, t: Type):
        result = ""
        if isinstance(t, ABC) and self._declaration:
            result = "\n    virtual void accept(Visitor& visitor) const = 0;"
        if not isinstance(t, ABC):
            if self._declaration:
                result = "\n    void accept(Visitor& visitor) const override {{ visitor.visit(*this); }}"
            else:
                result = f"\n\n\nvoid {t.name}::accept(Visitor& visitor) const override {{ visitor.visit(*this); }}"
        return result

    def generate_ast_class_fields(self, t: Type):
        if isinstance(t, ABC):
            return ""
        return "\n".join([""] + [f"    const {field.type} {field.name};" for field in t.fields])

    def generate_ast_class_footer(self, t: Type):
        return "\n};"

    def generate_visitor(self):
        if self._declaration:
            return "".join([
                self.generate_visitor_header(),
                self.generate_visitor_methods(),
                self.generate_visitor_footer(),
            ])
        return ""

    def generate_visitor_header(self):
        return "\n\n\nclass Visitor\n{"

    def generate_visitor_methods(self):
        assert(self._declaration)
        return "".join([
            f"\n    virtual void visit(const {type}& {type.lower()}) = 0;"
            for type in self._visitable_types
        ])

    def generate_visitor_footer(self):
        return "\n};"


def parse_args():
    parser = argparse.ArgumentParser(
        description="Generate AST classes for the parser.",
    )
    parser.add_argument(
        "language",
        choices=["cpp"],
        help="The output programming language.",
    )
    parser.add_argument(
        "--declaration",
        action="store_true",
        help="Whether to generate the AST classes as declarations or definitions.",
    )
    return parser.parse_args()


def main():
    args = parse_args()
    if args.language == "cpp":
        metaprogrammer = CppAstMetaProgrammer(TYPES, args.declaration)
    else:
        raise Exception("Invalid language: {}".format(args.language))
    print(metaprogrammer.generate(), end="")


if __name__ == "__main__":
    main()
